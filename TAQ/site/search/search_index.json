{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue ! Bienvenue sur TAQ , le site d\u00e9di\u00e9 aux cours de NSI (Num\u00e9rique et Sciences Informatiques) et SNT (Sciences Num\u00e9riques et Technologie) de M.Quertier. \u00c0 propos des mati\u00e8res NSI (Num\u00e9rique et Sciences Informatiques) : Cette mati\u00e8re est destin\u00e9e aux \u00e9l\u00e8ves de Premi\u00e8re et Terminale. Elle permet de d\u00e9couvrir la programmation, les structures de donn\u00e9es, les algorithmes et la logique informatique. L\u2019objectif est de d\u00e9velopper la capacit\u00e9 \u00e0 r\u00e9soudre des probl\u00e8mes avec les outils num\u00e9riques . SNT (Sciences Num\u00e9riques et Technologie) : Cette mati\u00e8re est enseign\u00e9e en Seconde et permet d\u2019explorer les grands concepts du num\u00e9rique : r\u00e9seaux, web, donn\u00e9es, cybers\u00e9curit\u00e9, algorithmes et objets connect\u00e9s. L\u2019objectif est de comprendre le fonctionnement du monde num\u00e9rique qui nous entoure . Organisation du site Ce site centralise tous vos cours pour chaque niveau : \ud83d\udd39 SNT - Secondes \ud83d\udd38 NSI - Premi\u00e8res \ud83d\udd3a NSI - Terminales","title":"Accueil"},{"location":"#bienvenue","text":"Bienvenue sur TAQ , le site d\u00e9di\u00e9 aux cours de NSI (Num\u00e9rique et Sciences Informatiques) et SNT (Sciences Num\u00e9riques et Technologie) de M.Quertier.","title":"Bienvenue !"},{"location":"#a-propos-des-matieres","text":"NSI (Num\u00e9rique et Sciences Informatiques) : Cette mati\u00e8re est destin\u00e9e aux \u00e9l\u00e8ves de Premi\u00e8re et Terminale. Elle permet de d\u00e9couvrir la programmation, les structures de donn\u00e9es, les algorithmes et la logique informatique. L\u2019objectif est de d\u00e9velopper la capacit\u00e9 \u00e0 r\u00e9soudre des probl\u00e8mes avec les outils num\u00e9riques . SNT (Sciences Num\u00e9riques et Technologie) : Cette mati\u00e8re est enseign\u00e9e en Seconde et permet d\u2019explorer les grands concepts du num\u00e9rique : r\u00e9seaux, web, donn\u00e9es, cybers\u00e9curit\u00e9, algorithmes et objets connect\u00e9s. L\u2019objectif est de comprendre le fonctionnement du monde num\u00e9rique qui nous entoure .","title":"\u00c0 propos des mati\u00e8res"},{"location":"#organisation-du-site","text":"Ce site centralise tous vos cours pour chaque niveau : \ud83d\udd39 SNT - Secondes \ud83d\udd38 NSI - Premi\u00e8res \ud83d\udd3a NSI - Terminales","title":"Organisation du site"},{"location":"Premieres/Premieres/","text":"NSI - Premi\u00e8res Chapitres \ud83d\udd39 1 - Types de base","title":"Accueil"},{"location":"Premieres/Premieres/#nsi-premieres","text":"","title":"NSI - Premi\u00e8res"},{"location":"Premieres/Premieres/#chapitres","text":"\ud83d\udd39 1 - Types de base","title":"Chapitres"},{"location":"Premieres/Chapitres/Types_de_base/","text":"Types de base Entier positif Le d\u00e9cimal Depuis toujours, nous utilisons la base 10, s\u00fbrement parce que nous avons\u2026 10 doigts. C'est ce que l'on appelle le syst\u00e8me d\u00e9cimal , car nous utilisons 10 chiffres (de 0 \u00e0 9) pour repr\u00e9senter toutes les valeurs. Dans un nombre d\u00e9cimal, chaque position correspond \u00e0 une puissance de 10, de droite \u00e0 gauche. \\(10^3\\) \\(10^2\\) \\(10^1\\) \\(10^0\\) \\(2025_{10}\\) 2 0 2 5 \\[ 2025_{10} = 2 \\times 10^3 + 0 \\times 10^2 + 2 \\times 10^1 + 5 \\times 10^0 \\] \\[ = 2 \\times 1000 + 0 \\times 100 + 2 \\times 10 + 5 \\times 1 \\] Rappel sur les puissances Une puissance est une fa\u00e7on d\u2019\u00e9crire une multiplication r\u00e9p\u00e9t\u00e9e. \\( a^n \\) se lit \u00ab\u202fa puissance n\u202f\u00bb et signifie que l\u2019on multiplie \\(a\\) par lui-m\u00eame \\(n\\) fois : $$ a^n = \\underbrace{a \\times a \\times \\dots \\times a}_{n \\text{ fois}} $$ exemples \\( 2^3 = 2 \\times 2 \\times 2 = 8 \\) \\( 5^0 = 1 \\) (par convention, toute base non nulle \u00e0 la puissance 0 vaut 1) \\( 10^4 = 10 \\times 10 \\times 10 \\times 10 = 10000 \\) Le binaire L\u2019ordinateur utilise la base 2, appel\u00e9e binaire , car les composants \u00e9lectroniques ne peuvent traiter que deux \u00e9tats : - 1 : pr\u00e9sence d\u2019une tension \u00e9lectrique - 0 : absence de tension \u00e9lectrique Il a donc fallu repr\u00e9senter toutes les informations en binaire. Dans ce syst\u00e8me, il n\u2019existe que deux symboles : 0 et 1, que l\u2019on appelle des bits (contraction de binary digit). Chaque position dans un nombre binaire correspond \u00e0 une puissance de 2 , de droite \u00e0 gauche. exemple Prenons le nombre binaire : \\(1011_2\\) On peut le d\u00e9composer en puissances de 2 : \\(2^3\\) \\(2^2\\) \\(2^1\\) \\(2^0\\) \\(1011_2\\) 1 0 1 1 Et le convertir en d\u00e9cimal : \\[ 1011_2 = 1 \\times 2^3 + 0 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^0 \\] \\[ = 2^3 + 2^1 + 2^0 \\] \\[ = 8 + 2 + 1 \\] \\[ = 11 \\] donc \\(1011_{2} = 11_{10}\\) Exercice Convertir en d\u00e9cimal, ces valeurs binaires : \\(110010_{2}\\) \\(1100100_{2}\\) \\(100100101_{2}\\) Conversion du d\u00e9cimal vers le binaire On utilise la M\u00e9thode des divisions successives On divise le nombre par 2 . On note le reste (0 ou 1). On recommence avec le quotient , jusqu\u2019\u00e0 obtenir 0. Le nombre binaire est obtenu en lisant les restes de bas en haut . exemple Repr\u00e9sentons la valeur \\(50_{10}\\) en binaire. 50 / 2 = 25 reste 0 25 / 2 = 12 reste 1 12 / 2 = 6 reste 0 6 / 2 = 3 reste 0 3 / 2 = 1 reste 1 1 / 2 = 0 reste 1 donc \\(50_{10} = 110010_{2}\\) Exercice Convertir en binaire, ces valeurs d\u00e9cimales : \\(2025_{10}\\) \\(4050_{10}\\) \\(59400_{10}\\) L\u2019hexad\u00e9cimal Un autre syst\u00e8me de num\u00e9ration tr\u00e8s utilis\u00e9 en informatique est la base 16 , appel\u00e9e hexad\u00e9cimal . Pourquoi ? Parce qu\u2019il est plus compact que le binaire : au lieu de manipuler des suites tr\u00e8s longues de 0 et 1, on peut les regrouper par 4 bits (4 chiffres binaires) et les \u00e9crire avec un seul chiffre hexad\u00e9cimal. Les chiffres en base 16 La base 16 utilise 16 symboles diff\u00e9rents : - de 0 \u00e0 9 (comme en d\u00e9cimal) - puis les lettres A, B, C, D, E, F pour repr\u00e9senter les valeurs 10 \u00e0 15. D\u00e9cimal Hexad\u00e9cimal 10 A 11 B 12 C 13 D 14 E 15 F exemple \\(16^1\\) \\(16^0\\) \\(A2_{16}\\) A (= 10) 2 \\[ A2_{16} = 10 \\times 16^1 + 2 \\times 16^0 \\] \\[ = 160 + 2 \\] \\[ = 162_{10} \\] Lien entre binaire et hexad\u00e9cimal Chaque chiffre hexad\u00e9cimal correspond \u00e0 4 bits (car \\(2^4 = 16\\) ). Hexa 0 1 2 3 4 5 6 7 Binaire 0000 0001 0010 0011 0100 0101 0110 0111 Hexa 8 9 A B C D E F Binaire 1000 1001 1010 1011 1100 1101 1110 1111 Cela permet de convertir facilement du binaire en hexad\u00e9cimal en regroupant les bits par paquets de 4. exemple \\(111011_{2}\\) On regroupe par 4 bits (en partant de la droite) : 0011 1011 3 B Donc \\(111011_2 = 3B_{16}\\) Exercice Convertir en d\u00e9cimal : \\(FF_{16}\\) \\(1A3_{16}\\) Convertir en binaire : \\(7C4_{16}\\) \\(FADA_{16}\\) Convertir en hexad\u00e9cimal : \\(1999_{10}\\) \\(59400_{10}\\) \\(111100_{2}\\) \\(110100101111_{2}\\) Entier relatif Jusqu\u2019ici, nous avons vu la repr\u00e9sentation des entiers positifs . Mais il faut aussi repr\u00e9senter les entiers relatifs (positifs et n\u00e9gatifs). Nombre de bits n\u00e9cessaires En binaire, la taille d\u2019un entier est d\u00e9termin\u00e9e par le nombre de bits utilis\u00e9s. Avec n bits, on peut repr\u00e9senter au maximum : \\[ 0 \\; \\leqslant \\; N \\; < \\; 2^n \\] Exemple : - avec 8 bits (1 octet), on peut repr\u00e9senter 256 valeurs distinctes (de 0 \u00e0 255). - avec 16 bits , on peut repr\u00e9senter 65 536 valeurs (de 0 \u00e0 65 535). Les tailles courantes Les tailles les plus utilis\u00e9es en informatique sont : 8 bits (1 octet) 16 bits (2 octets) 32 bits (4 octets) 64 bits (8 octets) Chaque taille limite l\u2019intervalle de valeurs possibles. Questions Combien de valeurs diff\u00e9rentes peut-on repr\u00e9senter avec : 1. 5 bits ? 2. 10 bits ? 3. 32 bits ? Premi\u00e8re id\u00e9e : utiliser un bit de signe Une premi\u00e8re id\u00e9e consiste \u00e0 r\u00e9server le bit de poids fort (le plus \u00e0 gauche) pour indiquer le signe : - 0 \u2192 nombre positif - 1 \u2192 nombre n\u00e9gatif On aurait alors les repr\u00e9sentations suivantes sur 3 bits : n\u00e9gatif positif 0 100 000 1 101 001 2 110 010 3 111 011 Probl\u00e8mes de cette m\u00e9thode Deux repr\u00e9sentations pour la valeur 0. Cela introduit une incoh\u00e9rence et gaspille une combinaison binaire. Addition incorrecte Exemple avec \\( 5 + (-5) \\) sur 8 bits: \\(00000101_2 + 10000101_2 = 10001010_2\\) C'est \u00e0 dire \\(5 - 5 = - 10\\) , ce qui est \u00e9videmment faux ! Il faut donc trouver une autre m\u00e9thode. Exercice - Donner les repr\u00e9sentations binaires des valeurs entre -5 et 5 sur 4 bits. - Donner les repr\u00e9sentations binaires des valeurs -67 sur 8 bits. Solution : le compl\u00e9ment \u00e0 2 Pour corriger ces probl\u00e8mes, on utilise la m\u00e9thode du compl\u00e9ment \u00e0 2 . L\u2019id\u00e9e est comparable \u00e0 un compteur : - Si on compte en arri\u00e8re depuis 0 , on obtient directement le dernier nombre possible. - Exemple en base d\u00e9cimale avec deux chiffres : apr\u00e8s 00 , si on soustrait 1, on tombe sur 99 , puis 98 , etc. De la m\u00eame mani\u00e8re, en binaire, on utilise le \"rebouclage\" naturel des bits pour coder les nombres n\u00e9gatifs. n\u00e9gatif positif 0 000 1 111 001 2 110 010 3 101 011 4 100 M\u00e9thode de construction La m\u00e9thode est simple : Pour repr\u00e9senter un nombre n\u00e9gatif, on \u00e9crit en binaire sa valeur absolue, on inverse ensuite tous les bits, puis on ajoute 1. Exemple Imaginons que nous codions sur 4 bits. Nous voulons repr\u00e9senter la valeur -5. \\(5_{10} = 101_2\\) sur 4 bits : \\(0101_2\\) inversion des bits : \\(1010_2\\) +1 \u2192 \\(1011_2\\) Sur 4 bits, on r\u00e9presente donc -5 comme ceci : \\(1011_2\\) . Exercice Coder en compl\u00e9ment \u00e0 2 sur 4 bits les valeurs entre -5 et 5 sur 4 bits. Cette fois-ci l'addition fonctionne : Exemple Essayons de nouveau \\(5 + (-5)\\) sur 8 bits, c'est \u00e0 dire : \\(00000101_2 + 11111011_2\\) retenue 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 1 0 1 + 1 1 1 1 1 1 0 1 1 = 1 0 0 0 0 0 0 0 0 0 On obtient alors : \\(100000000_2\\) , or nous sommes sur 8 bits donc on a bien : \\(5_{10} + (-5_{10}) = 00000101_2 + 11111011_2 = 00000000_2 = 0_{10}\\) Exercice V\u00e9rifier \u00e0 la main les additions suivantes en compl\u00e9ment \u00e0 2 (sur 4 bits) : 1. \\(2 + (-2)\\) 2. \\(3 + (-1)\\) 3. \\(-3 + (-2)\\) Exercice Donner l\u2019intervalle des entiers repr\u00e9sentables avec : 1. 8 bits non sign\u00e9s 2. 8 bits avec bit de signe 3. 8 bits en compl\u00e9ment \u00e0 2 R\u00e9el Contrairement aux entiers, les nombres r\u00e9els peuvent avoir une partie fractionnaire . Pour les repr\u00e9senter en informatique, on utilise le format nombre \u00e0 virgule flottante ( floating point ). Conversion d\u00e9cimal vers binaire Prenons \\(6.34375_{10}\\) On peut s\u00e9parer cette valeur en deux : - la partie enti\u00e9re : 6 - la partie fractionnaire : 0.34375 On sait d\u00e9ja transformer les valeurs enti\u00e9re : \\(6_{10} = 110_2\\) Pour la partie fractionnaire, \u00e0 l'inverse, on va effectuer des multiplications successives : On multiplie notre valeur par 2. Puis on recommence avec la partie fractionnaire du resultat. Et ainsi de suite jusqu'\u00e0 ce que le resultat soit une valeur enti\u00e9re. \\(0.34375 \\times 2 = 0.6875\\) \\(0.6875 \\times 2 = 1.375\\) \\(0.375 \\times 2 = 0.75\\) \\(0.75 \\times 2 = 1.5\\) \\(0.5 \\times 2 = 1\\) Pour finir on regarde les valeurs enti\u00e9res des resultats de haut en bas. On a donc comme partie fractionnaire : \\(0.01011_2\\) . Pour finir, il nous suffit d'additionner nos deux r\u00e9sultats : \\(6.34375_{10} = 110.01011_2\\) . Conversion binaire vers d\u00e9cimal Ici, nous utiliserons la m\u00eame m\u00e9thode que pour les valeurs enti\u00e9res. Les bits de la partie fractionnaire correspondent \u00e0 des puissances n\u00e9gatives. Reprenons notre r\u00e9sultat pr\u00e9c\u00e9dent : \\(110.01011_2\\) . \\(2^2\\) \\(2^1\\) \\(2^0\\) \\(2^{-1}\\) \\(2^{-2}\\) \\(2^{-3}\\) \\(2^{-4}\\) \\(2^{-5}\\) 1 1 0 0 1 0 1 1 Pour retrouver notre valeur d\u00e9cimal nous pouvons effectuer ce calcul : $$ 2^2 + 2^1 + 2^{-2}+ 2^{-4}+ 2^{-5} = $$ $$4 + 2 + 0.25 + 0.0625 + 0.03125 = 6.34375 $$ Rappel sur les puissances Une puissance n\u00e9gative permet de repr\u00e9senter la division r\u00e9p\u00e9t\u00e9e . Pour tout nombre non nul \\(a\\) et tout entier \\(n > 0\\) : $$ a^{-n} = \\frac{1}{a^n} $$ Autrement dit, \\(a^{-n}\\) est l'inverse de \\(a^n\\) . \\(2^-1\\) \\(2^-2\\) \\(2^-3\\) \\(2^-4\\) \\(2^-5\\) \\(2^-6\\) \\(2^-7\\) \\(\\frac{1}{2^1}\\) \\(\\frac{1}{2^2}\\) \\(\\frac{1}{2^3}\\) \\(\\frac{1}{2^4}\\) \\(\\frac{1}{2^5}\\) \\(\\frac{1}{2^6}\\) \\(\\frac{1}{2^7}\\) \\(\\frac{1}{2}\\) \\(\\frac{1}{4}\\) \\(\\frac{1}{8}\\) \\(\\frac{1}{16}\\) \\(\\frac{1}{32}\\) \\(\\frac{1}{64}\\) \\(\\frac{1}{128}\\) \\(0.5\\) \\(0.25\\) \\(0.125\\) \\(0.0625\\) \\(0.03125\\) \\(0.015625\\) \\(0.0078125\\) Exemples \\(2^{-3} = \\frac{1}{2^3} = \\frac{1}{8} = 0.125\\) \\(5^{-2} = \\frac{1}{5^2} = \\frac{1}{25} = 0.04\\) \\(10^{-4} = \\frac{1}{10^4} = \\frac{1}{10000} = 0.0001\\) Ainsi, les puissances n\u00e9gatives sont tr\u00e8s utiles pour repr\u00e9senter les fractions et les nombres tr\u00e8s petits , notamment dans les nombres flottants. La norme IEEE 754 La norme IEEE 754 d\u00e9finit comment repr\u00e9senter un r\u00e9el sur un nombre fini de bits. Elle utilise trois composants : Signe (1 bit) : 0 \u2192 positif, 1 \u2192 n\u00e9gatif Exposant : encode la puissance de 2 Mantisse (ou fraction) : encode les chiffres significatifs Le nombre r\u00e9el est donc repr\u00e9sent\u00e9 comme : \\[ x = (-1)^{\\text{signe}} \\times 1.\\text{mantisse} \\times 2^{\\text{exposant}-\\text{biais}} \\] Le biais est un nombre ajout\u00e9 pour que l\u2019exposant puisse \u00eatre positif ou n\u00e9gatif. La mantisse permet de repr\u00e9senter les chiffres significatifs. Propri\u00e9t\u00e9s importantes Certains nombres ne peuvent pas \u00eatre repr\u00e9sent\u00e9s exactement. Exemple : \\(0.1_{10}\\) n\u2019a pas de repr\u00e9sentation binaire exacte. Les erreurs d\u2019arrondi peuvent s\u2019accumuler lors des calculs. Il ne faut jamais tester l\u2019\u00e9galit\u00e9 de deux flottants avec == . Exemples \\(0.25_{10} = 0.01_2\\) exactement \\(0.1_{10}\\) = une suite infinie en binaire \u2192 approximation \\(1/3_{10} \\approx 0.3333...\\) \u2192 approximation Exercices Convertir les nombres suivants en binaire flottant (approximatif sur 8 bits de mantisse) : 0.1 0.25 1/3 V\u00e9rifier pourquoi 0.2 + 0.1 != 0.3 en Python ou en pseudo-code.","title":"Types de base"},{"location":"Premieres/Chapitres/Types_de_base/#types-de-base","text":"","title":"Types de base"},{"location":"Premieres/Chapitres/Types_de_base/#entier-positif","text":"","title":"Entier positif"},{"location":"Premieres/Chapitres/Types_de_base/#le-decimal","text":"Depuis toujours, nous utilisons la base 10, s\u00fbrement parce que nous avons\u2026 10 doigts. C'est ce que l'on appelle le syst\u00e8me d\u00e9cimal , car nous utilisons 10 chiffres (de 0 \u00e0 9) pour repr\u00e9senter toutes les valeurs. Dans un nombre d\u00e9cimal, chaque position correspond \u00e0 une puissance de 10, de droite \u00e0 gauche. \\(10^3\\) \\(10^2\\) \\(10^1\\) \\(10^0\\) \\(2025_{10}\\) 2 0 2 5 \\[ 2025_{10} = 2 \\times 10^3 + 0 \\times 10^2 + 2 \\times 10^1 + 5 \\times 10^0 \\] \\[ = 2 \\times 1000 + 0 \\times 100 + 2 \\times 10 + 5 \\times 1 \\] Rappel sur les puissances Une puissance est une fa\u00e7on d\u2019\u00e9crire une multiplication r\u00e9p\u00e9t\u00e9e. \\( a^n \\) se lit \u00ab\u202fa puissance n\u202f\u00bb et signifie que l\u2019on multiplie \\(a\\) par lui-m\u00eame \\(n\\) fois : $$ a^n = \\underbrace{a \\times a \\times \\dots \\times a}_{n \\text{ fois}} $$ exemples \\( 2^3 = 2 \\times 2 \\times 2 = 8 \\) \\( 5^0 = 1 \\) (par convention, toute base non nulle \u00e0 la puissance 0 vaut 1) \\( 10^4 = 10 \\times 10 \\times 10 \\times 10 = 10000 \\)","title":"Le d\u00e9cimal"},{"location":"Premieres/Chapitres/Types_de_base/#le-binaire","text":"L\u2019ordinateur utilise la base 2, appel\u00e9e binaire , car les composants \u00e9lectroniques ne peuvent traiter que deux \u00e9tats : - 1 : pr\u00e9sence d\u2019une tension \u00e9lectrique - 0 : absence de tension \u00e9lectrique Il a donc fallu repr\u00e9senter toutes les informations en binaire. Dans ce syst\u00e8me, il n\u2019existe que deux symboles : 0 et 1, que l\u2019on appelle des bits (contraction de binary digit). Chaque position dans un nombre binaire correspond \u00e0 une puissance de 2 , de droite \u00e0 gauche. exemple Prenons le nombre binaire : \\(1011_2\\) On peut le d\u00e9composer en puissances de 2 : \\(2^3\\) \\(2^2\\) \\(2^1\\) \\(2^0\\) \\(1011_2\\) 1 0 1 1 Et le convertir en d\u00e9cimal : \\[ 1011_2 = 1 \\times 2^3 + 0 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^0 \\] \\[ = 2^3 + 2^1 + 2^0 \\] \\[ = 8 + 2 + 1 \\] \\[ = 11 \\] donc \\(1011_{2} = 11_{10}\\) Exercice Convertir en d\u00e9cimal, ces valeurs binaires : \\(110010_{2}\\) \\(1100100_{2}\\) \\(100100101_{2}\\)","title":"Le binaire"},{"location":"Premieres/Chapitres/Types_de_base/#conversion-du-decimal-vers-le-binaire","text":"On utilise la M\u00e9thode des divisions successives On divise le nombre par 2 . On note le reste (0 ou 1). On recommence avec le quotient , jusqu\u2019\u00e0 obtenir 0. Le nombre binaire est obtenu en lisant les restes de bas en haut . exemple Repr\u00e9sentons la valeur \\(50_{10}\\) en binaire. 50 / 2 = 25 reste 0 25 / 2 = 12 reste 1 12 / 2 = 6 reste 0 6 / 2 = 3 reste 0 3 / 2 = 1 reste 1 1 / 2 = 0 reste 1 donc \\(50_{10} = 110010_{2}\\) Exercice Convertir en binaire, ces valeurs d\u00e9cimales : \\(2025_{10}\\) \\(4050_{10}\\) \\(59400_{10}\\)","title":"Conversion du d\u00e9cimal vers le binaire"},{"location":"Premieres/Chapitres/Types_de_base/#lhexadecimal","text":"Un autre syst\u00e8me de num\u00e9ration tr\u00e8s utilis\u00e9 en informatique est la base 16 , appel\u00e9e hexad\u00e9cimal . Pourquoi ? Parce qu\u2019il est plus compact que le binaire : au lieu de manipuler des suites tr\u00e8s longues de 0 et 1, on peut les regrouper par 4 bits (4 chiffres binaires) et les \u00e9crire avec un seul chiffre hexad\u00e9cimal.","title":"L\u2019hexad\u00e9cimal"},{"location":"Premieres/Chapitres/Types_de_base/#les-chiffres-en-base-16","text":"La base 16 utilise 16 symboles diff\u00e9rents : - de 0 \u00e0 9 (comme en d\u00e9cimal) - puis les lettres A, B, C, D, E, F pour repr\u00e9senter les valeurs 10 \u00e0 15. D\u00e9cimal Hexad\u00e9cimal 10 A 11 B 12 C 13 D 14 E 15 F exemple \\(16^1\\) \\(16^0\\) \\(A2_{16}\\) A (= 10) 2 \\[ A2_{16} = 10 \\times 16^1 + 2 \\times 16^0 \\] \\[ = 160 + 2 \\] \\[ = 162_{10} \\]","title":"Les chiffres en base 16"},{"location":"Premieres/Chapitres/Types_de_base/#lien-entre-binaire-et-hexadecimal","text":"Chaque chiffre hexad\u00e9cimal correspond \u00e0 4 bits (car \\(2^4 = 16\\) ). Hexa 0 1 2 3 4 5 6 7 Binaire 0000 0001 0010 0011 0100 0101 0110 0111 Hexa 8 9 A B C D E F Binaire 1000 1001 1010 1011 1100 1101 1110 1111 Cela permet de convertir facilement du binaire en hexad\u00e9cimal en regroupant les bits par paquets de 4. exemple \\(111011_{2}\\) On regroupe par 4 bits (en partant de la droite) : 0011 1011 3 B Donc \\(111011_2 = 3B_{16}\\) Exercice Convertir en d\u00e9cimal : \\(FF_{16}\\) \\(1A3_{16}\\) Convertir en binaire : \\(7C4_{16}\\) \\(FADA_{16}\\) Convertir en hexad\u00e9cimal : \\(1999_{10}\\) \\(59400_{10}\\) \\(111100_{2}\\) \\(110100101111_{2}\\)","title":"Lien entre binaire et hexad\u00e9cimal"},{"location":"Premieres/Chapitres/Types_de_base/#entier-relatif","text":"Jusqu\u2019ici, nous avons vu la repr\u00e9sentation des entiers positifs . Mais il faut aussi repr\u00e9senter les entiers relatifs (positifs et n\u00e9gatifs).","title":"Entier relatif"},{"location":"Premieres/Chapitres/Types_de_base/#nombre-de-bits-necessaires","text":"En binaire, la taille d\u2019un entier est d\u00e9termin\u00e9e par le nombre de bits utilis\u00e9s. Avec n bits, on peut repr\u00e9senter au maximum : \\[ 0 \\; \\leqslant \\; N \\; < \\; 2^n \\] Exemple : - avec 8 bits (1 octet), on peut repr\u00e9senter 256 valeurs distinctes (de 0 \u00e0 255). - avec 16 bits , on peut repr\u00e9senter 65 536 valeurs (de 0 \u00e0 65 535). Les tailles courantes Les tailles les plus utilis\u00e9es en informatique sont : 8 bits (1 octet) 16 bits (2 octets) 32 bits (4 octets) 64 bits (8 octets) Chaque taille limite l\u2019intervalle de valeurs possibles. Questions Combien de valeurs diff\u00e9rentes peut-on repr\u00e9senter avec : 1. 5 bits ? 2. 10 bits ? 3. 32 bits ?","title":"Nombre de bits n\u00e9cessaires"},{"location":"Premieres/Chapitres/Types_de_base/#premiere-idee-utiliser-un-bit-de-signe","text":"Une premi\u00e8re id\u00e9e consiste \u00e0 r\u00e9server le bit de poids fort (le plus \u00e0 gauche) pour indiquer le signe : - 0 \u2192 nombre positif - 1 \u2192 nombre n\u00e9gatif On aurait alors les repr\u00e9sentations suivantes sur 3 bits : n\u00e9gatif positif 0 100 000 1 101 001 2 110 010 3 111 011 Probl\u00e8mes de cette m\u00e9thode Deux repr\u00e9sentations pour la valeur 0. Cela introduit une incoh\u00e9rence et gaspille une combinaison binaire. Addition incorrecte Exemple avec \\( 5 + (-5) \\) sur 8 bits: \\(00000101_2 + 10000101_2 = 10001010_2\\) C'est \u00e0 dire \\(5 - 5 = - 10\\) , ce qui est \u00e9videmment faux ! Il faut donc trouver une autre m\u00e9thode. Exercice - Donner les repr\u00e9sentations binaires des valeurs entre -5 et 5 sur 4 bits. - Donner les repr\u00e9sentations binaires des valeurs -67 sur 8 bits.","title":"Premi\u00e8re id\u00e9e : utiliser un bit de signe"},{"location":"Premieres/Chapitres/Types_de_base/#solution-le-complement-a-2","text":"Pour corriger ces probl\u00e8mes, on utilise la m\u00e9thode du compl\u00e9ment \u00e0 2 . L\u2019id\u00e9e est comparable \u00e0 un compteur : - Si on compte en arri\u00e8re depuis 0 , on obtient directement le dernier nombre possible. - Exemple en base d\u00e9cimale avec deux chiffres : apr\u00e8s 00 , si on soustrait 1, on tombe sur 99 , puis 98 , etc. De la m\u00eame mani\u00e8re, en binaire, on utilise le \"rebouclage\" naturel des bits pour coder les nombres n\u00e9gatifs. n\u00e9gatif positif 0 000 1 111 001 2 110 010 3 101 011 4 100","title":"Solution : le compl\u00e9ment \u00e0 2"},{"location":"Premieres/Chapitres/Types_de_base/#methode-de-construction","text":"La m\u00e9thode est simple : Pour repr\u00e9senter un nombre n\u00e9gatif, on \u00e9crit en binaire sa valeur absolue, on inverse ensuite tous les bits, puis on ajoute 1. Exemple Imaginons que nous codions sur 4 bits. Nous voulons repr\u00e9senter la valeur -5. \\(5_{10} = 101_2\\) sur 4 bits : \\(0101_2\\) inversion des bits : \\(1010_2\\) +1 \u2192 \\(1011_2\\) Sur 4 bits, on r\u00e9presente donc -5 comme ceci : \\(1011_2\\) . Exercice Coder en compl\u00e9ment \u00e0 2 sur 4 bits les valeurs entre -5 et 5 sur 4 bits. Cette fois-ci l'addition fonctionne : Exemple Essayons de nouveau \\(5 + (-5)\\) sur 8 bits, c'est \u00e0 dire : \\(00000101_2 + 11111011_2\\) retenue 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 1 0 1 + 1 1 1 1 1 1 0 1 1 = 1 0 0 0 0 0 0 0 0 0 On obtient alors : \\(100000000_2\\) , or nous sommes sur 8 bits donc on a bien : \\(5_{10} + (-5_{10}) = 00000101_2 + 11111011_2 = 00000000_2 = 0_{10}\\) Exercice V\u00e9rifier \u00e0 la main les additions suivantes en compl\u00e9ment \u00e0 2 (sur 4 bits) : 1. \\(2 + (-2)\\) 2. \\(3 + (-1)\\) 3. \\(-3 + (-2)\\) Exercice Donner l\u2019intervalle des entiers repr\u00e9sentables avec : 1. 8 bits non sign\u00e9s 2. 8 bits avec bit de signe 3. 8 bits en compl\u00e9ment \u00e0 2","title":"M\u00e9thode de construction"},{"location":"Premieres/Chapitres/Types_de_base/#reel","text":"Contrairement aux entiers, les nombres r\u00e9els peuvent avoir une partie fractionnaire . Pour les repr\u00e9senter en informatique, on utilise le format nombre \u00e0 virgule flottante ( floating point ).","title":"R\u00e9el"},{"location":"Premieres/Chapitres/Types_de_base/#conversion-decimal-vers-binaire","text":"Prenons \\(6.34375_{10}\\) On peut s\u00e9parer cette valeur en deux : - la partie enti\u00e9re : 6 - la partie fractionnaire : 0.34375 On sait d\u00e9ja transformer les valeurs enti\u00e9re : \\(6_{10} = 110_2\\) Pour la partie fractionnaire, \u00e0 l'inverse, on va effectuer des multiplications successives : On multiplie notre valeur par 2. Puis on recommence avec la partie fractionnaire du resultat. Et ainsi de suite jusqu'\u00e0 ce que le resultat soit une valeur enti\u00e9re. \\(0.34375 \\times 2 = 0.6875\\) \\(0.6875 \\times 2 = 1.375\\) \\(0.375 \\times 2 = 0.75\\) \\(0.75 \\times 2 = 1.5\\) \\(0.5 \\times 2 = 1\\) Pour finir on regarde les valeurs enti\u00e9res des resultats de haut en bas. On a donc comme partie fractionnaire : \\(0.01011_2\\) . Pour finir, il nous suffit d'additionner nos deux r\u00e9sultats : \\(6.34375_{10} = 110.01011_2\\) .","title":"Conversion d\u00e9cimal vers binaire"},{"location":"Premieres/Chapitres/Types_de_base/#conversion-binaire-vers-decimal","text":"Ici, nous utiliserons la m\u00eame m\u00e9thode que pour les valeurs enti\u00e9res. Les bits de la partie fractionnaire correspondent \u00e0 des puissances n\u00e9gatives. Reprenons notre r\u00e9sultat pr\u00e9c\u00e9dent : \\(110.01011_2\\) . \\(2^2\\) \\(2^1\\) \\(2^0\\) \\(2^{-1}\\) \\(2^{-2}\\) \\(2^{-3}\\) \\(2^{-4}\\) \\(2^{-5}\\) 1 1 0 0 1 0 1 1 Pour retrouver notre valeur d\u00e9cimal nous pouvons effectuer ce calcul : $$ 2^2 + 2^1 + 2^{-2}+ 2^{-4}+ 2^{-5} = $$ $$4 + 2 + 0.25 + 0.0625 + 0.03125 = 6.34375 $$ Rappel sur les puissances Une puissance n\u00e9gative permet de repr\u00e9senter la division r\u00e9p\u00e9t\u00e9e . Pour tout nombre non nul \\(a\\) et tout entier \\(n > 0\\) : $$ a^{-n} = \\frac{1}{a^n} $$ Autrement dit, \\(a^{-n}\\) est l'inverse de \\(a^n\\) . \\(2^-1\\) \\(2^-2\\) \\(2^-3\\) \\(2^-4\\) \\(2^-5\\) \\(2^-6\\) \\(2^-7\\) \\(\\frac{1}{2^1}\\) \\(\\frac{1}{2^2}\\) \\(\\frac{1}{2^3}\\) \\(\\frac{1}{2^4}\\) \\(\\frac{1}{2^5}\\) \\(\\frac{1}{2^6}\\) \\(\\frac{1}{2^7}\\) \\(\\frac{1}{2}\\) \\(\\frac{1}{4}\\) \\(\\frac{1}{8}\\) \\(\\frac{1}{16}\\) \\(\\frac{1}{32}\\) \\(\\frac{1}{64}\\) \\(\\frac{1}{128}\\) \\(0.5\\) \\(0.25\\) \\(0.125\\) \\(0.0625\\) \\(0.03125\\) \\(0.015625\\) \\(0.0078125\\) Exemples \\(2^{-3} = \\frac{1}{2^3} = \\frac{1}{8} = 0.125\\) \\(5^{-2} = \\frac{1}{5^2} = \\frac{1}{25} = 0.04\\) \\(10^{-4} = \\frac{1}{10^4} = \\frac{1}{10000} = 0.0001\\)","title":"Conversion binaire vers d\u00e9cimal"},{"location":"Premieres/Chapitres/Types_de_base/#ainsi-les-puissances-negatives-sont-tres-utiles-pour-representer-les-fractions-et-les-nombres-tres-petits-notamment-dans-les-nombres-flottants","text":"","title":"Ainsi, les puissances n\u00e9gatives sont tr\u00e8s utiles pour repr\u00e9senter les fractions et les nombres tr\u00e8s petits, notamment dans les nombres flottants."},{"location":"Premieres/Chapitres/Types_de_base/#la-norme-ieee-754","text":"La norme IEEE 754 d\u00e9finit comment repr\u00e9senter un r\u00e9el sur un nombre fini de bits. Elle utilise trois composants : Signe (1 bit) : 0 \u2192 positif, 1 \u2192 n\u00e9gatif Exposant : encode la puissance de 2 Mantisse (ou fraction) : encode les chiffres significatifs Le nombre r\u00e9el est donc repr\u00e9sent\u00e9 comme : \\[ x = (-1)^{\\text{signe}} \\times 1.\\text{mantisse} \\times 2^{\\text{exposant}-\\text{biais}} \\] Le biais est un nombre ajout\u00e9 pour que l\u2019exposant puisse \u00eatre positif ou n\u00e9gatif. La mantisse permet de repr\u00e9senter les chiffres significatifs.","title":"La norme IEEE 754"},{"location":"Premieres/Chapitres/Types_de_base/#proprietes-importantes","text":"Certains nombres ne peuvent pas \u00eatre repr\u00e9sent\u00e9s exactement. Exemple : \\(0.1_{10}\\) n\u2019a pas de repr\u00e9sentation binaire exacte. Les erreurs d\u2019arrondi peuvent s\u2019accumuler lors des calculs. Il ne faut jamais tester l\u2019\u00e9galit\u00e9 de deux flottants avec == . Exemples \\(0.25_{10} = 0.01_2\\) exactement \\(0.1_{10}\\) = une suite infinie en binaire \u2192 approximation \\(1/3_{10} \\approx 0.3333...\\) \u2192 approximation Exercices Convertir les nombres suivants en binaire flottant (approximatif sur 8 bits de mantisse) : 0.1 0.25 1/3 V\u00e9rifier pourquoi 0.2 + 0.1 != 0.3 en Python ou en pseudo-code.","title":"Propri\u00e9t\u00e9s importantes"},{"location":"Secondes/Secondes/","text":"SNT - Secondes L\u2019enseignement de Sciences Num\u00e9riques et Technologie (SNT) en classe de Seconde permet de d\u00e9couvrir les principaux concepts du num\u00e9rique et de comprendre l\u2019impact croissant des technologies sur notre quotidien. Les mobiles, ordinateurs et objets connect\u00e9s sont des exemples concrets : ils permettent de communiquer, de cr\u00e9er, de se localiser, de traiter des donn\u00e9es et d\u2019interagir avec le monde. Cet enseignement s\u2019appuie sur quelques concepts fondamentaux : - Les donn\u00e9es : textes, images, sons, mesures\u2026 tout peut \u00eatre repr\u00e9sent\u00e9 num\u00e9riquement. - Les algorithmes : instructions permettant de traiter ces donn\u00e9es. - Les langages : pour traduire les algorithmes en programmes ex\u00e9cutables. - Les machines et objets connect\u00e9s : pour ex\u00e9cuter les programmes et g\u00e9rer les donn\u00e9es. - Les interfaces : pour interagir avec les humains et les syst\u00e8mes. L\u2019objectif est de mieux comprendre le num\u00e9rique, ses enjeux scientifiques et soci\u00e9taux, et d\u2019adopter un usage r\u00e9fl\u00e9chi et responsable des technologies. Chaque th\u00e8me du programme (Internet, Web, r\u00e9seaux sociaux, donn\u00e9es, localisation, objets connect\u00e9s, photographie num\u00e9rique\u2026) est accompagn\u00e9 de projets, travaux pratiques et activit\u00e9s pour mettre en pratique les connaissances. Chapitres \ud83d\udd39 Les bases de Python","title":"Accueil"},{"location":"Secondes/Secondes/#snt-secondes","text":"L\u2019enseignement de Sciences Num\u00e9riques et Technologie (SNT) en classe de Seconde permet de d\u00e9couvrir les principaux concepts du num\u00e9rique et de comprendre l\u2019impact croissant des technologies sur notre quotidien. Les mobiles, ordinateurs et objets connect\u00e9s sont des exemples concrets : ils permettent de communiquer, de cr\u00e9er, de se localiser, de traiter des donn\u00e9es et d\u2019interagir avec le monde. Cet enseignement s\u2019appuie sur quelques concepts fondamentaux : - Les donn\u00e9es : textes, images, sons, mesures\u2026 tout peut \u00eatre repr\u00e9sent\u00e9 num\u00e9riquement. - Les algorithmes : instructions permettant de traiter ces donn\u00e9es. - Les langages : pour traduire les algorithmes en programmes ex\u00e9cutables. - Les machines et objets connect\u00e9s : pour ex\u00e9cuter les programmes et g\u00e9rer les donn\u00e9es. - Les interfaces : pour interagir avec les humains et les syst\u00e8mes. L\u2019objectif est de mieux comprendre le num\u00e9rique, ses enjeux scientifiques et soci\u00e9taux, et d\u2019adopter un usage r\u00e9fl\u00e9chi et responsable des technologies. Chaque th\u00e8me du programme (Internet, Web, r\u00e9seaux sociaux, donn\u00e9es, localisation, objets connect\u00e9s, photographie num\u00e9rique\u2026) est accompagn\u00e9 de projets, travaux pratiques et activit\u00e9s pour mettre en pratique les connaissances.","title":"SNT - Secondes"},{"location":"Secondes/Secondes/#chapitres","text":"\ud83d\udd39 Les bases de Python","title":"Chapitres"},{"location":"Secondes/bases_python/","text":"Bases de Python Introduction Python est le langage choisi pour l\u2019enseignement de la sp\u00e9cialit\u00e9 NSI. Pourquoi Python ? - Il est simple d\u2019\u00e9criture et de lecture. - Il est libre et gratuit , disponible sur toutes les plateformes. - Il est interpr\u00e9t\u00e9 : pas besoin de compilation, on peut tester rapidement son code. - Il poss\u00e8de de nombreuses biblioth\u00e8ques utiles en math\u00e9matiques, sciences, \u00e9conomie, etc. 1. Variables et affectations Une variable permet de stocker une valeur en m\u00e9moire. L\u2019op\u00e9ration qui associe une valeur \u00e0 une variable s\u2019appelle une affectation . x = 5 y = 3 z = x + y print(z) # affiche z \ud83d\udc49 Ici, x et y contiennent des entiers, et z re\u00e7oit la somme. \u26a0\ufe0f En Python, le signe = n\u2019a pas le m\u00eame sens qu\u2019en math\u00e9matiques : il signifie \u00ab prend la valeur \u00bb . Exercice - Affecter la valeur 2025 \u00e0 une variable annee , puis afficher annee + 10 . 2. S\u00e9quences (cha\u00eenes, listes) Une s\u00e9quence est une collection ordonn\u00e9e d\u2019\u00e9l\u00e9ments. Les deux s\u00e9quences principales en Python sont : La cha\u00eene de caract\u00e8res ( str ) nom = \"Python\" print(nom[0]) # affiche 'P' print(len(nom)) # affiche 6 La liste ( list ) notes = [15, 12, 18] print(notes[1]) # affiche 12 notes.append(14) # ajoute 14 \u00e0 la liste Exercice Cr\u00e9er une liste contenant trois pr\u00e9noms et afficher le deuxi\u00e8me. 3. Instructions conditionnelles Elles permettent d\u2019 ex\u00e9cuter du code seulement si une condition est vraie . age = 17 if age >= 18: print(\"Majeur\") else: print(\"Mineur\") On peut ajouter plusieurs cas avec elif . note = 15 if note >= 16: print(\"Tr\u00e8s bien\") elif note >= 12: print(\"Assez bien\") else: print(\"\u00c0 am\u00e9liorer\") Exercice Demander \u00e0 l\u2019utilisateur son \u00e2ge avec input() , puis afficher : - \u00ab Mineur \u00bb si l\u2019\u00e2ge est < 18 - \u00ab Majeur \u00bb sinon 4. Boucles Les boucles permettent de r\u00e9p\u00e9ter des instructions . Boucle born\u00e9e : on conna\u00eet \u00e0 l\u2019avance le nombre de r\u00e9p\u00e9titions. for i in range(5): print(\"Bonjour\", i) Boucle non born\u00e9e : on r\u00e9p\u00e8te tant qu\u2019une condition est vraie. n = 0 while n < 5: print(\"n =\", n) n = n + 1 Exercice \u00c9crire un programme qui affiche les entiers de 1 \u00e0 10 avec une boucle while . 5. Fonctions Une fonction permet de regrouper un ensemble d\u2019instructions sous un nom. On peut ensuite l\u2019 appeler autant de fois que n\u00e9cessaire. def carre(x): return x * x print(carre(5)) # affiche 25 \ud83d\udc49 def sert \u00e0 d\u00e9finir la fonction. return renvoie le r\u00e9sultat. Exercice \u00c9crire une fonction aire_rectangle(longueur, largeur) qui renvoie l\u2019aire du rectangle. Tester avec plusieurs valeurs. Conclusion Avec ces bases (variables, s\u00e9quences, conditions, boucles, fonctions), on peut d\u00e9j\u00e0 : - r\u00e9soudre des probl\u00e8mes concrets, - mod\u00e9liser des ph\u00e9nom\u00e8nes, - \u00e9crire des programmes utiles et r\u00e9utilisables. C\u2019est la fondation de l\u2019apprentissage en NSI.","title":"Bases de Python"},{"location":"Secondes/bases_python/#bases-de-python","text":"","title":"Bases de Python"},{"location":"Secondes/bases_python/#introduction","text":"Python est le langage choisi pour l\u2019enseignement de la sp\u00e9cialit\u00e9 NSI. Pourquoi Python ? - Il est simple d\u2019\u00e9criture et de lecture. - Il est libre et gratuit , disponible sur toutes les plateformes. - Il est interpr\u00e9t\u00e9 : pas besoin de compilation, on peut tester rapidement son code. - Il poss\u00e8de de nombreuses biblioth\u00e8ques utiles en math\u00e9matiques, sciences, \u00e9conomie, etc.","title":"Introduction"},{"location":"Secondes/bases_python/#1-variables-et-affectations","text":"Une variable permet de stocker une valeur en m\u00e9moire. L\u2019op\u00e9ration qui associe une valeur \u00e0 une variable s\u2019appelle une affectation . x = 5 y = 3 z = x + y print(z) # affiche z \ud83d\udc49 Ici, x et y contiennent des entiers, et z re\u00e7oit la somme. \u26a0\ufe0f En Python, le signe = n\u2019a pas le m\u00eame sens qu\u2019en math\u00e9matiques : il signifie \u00ab prend la valeur \u00bb . Exercice - Affecter la valeur 2025 \u00e0 une variable annee , puis afficher annee + 10 .","title":"1. Variables et affectations"},{"location":"Secondes/bases_python/#2-sequences-chaines-listes","text":"Une s\u00e9quence est une collection ordonn\u00e9e d\u2019\u00e9l\u00e9ments. Les deux s\u00e9quences principales en Python sont : La cha\u00eene de caract\u00e8res ( str ) nom = \"Python\" print(nom[0]) # affiche 'P' print(len(nom)) # affiche 6 La liste ( list ) notes = [15, 12, 18] print(notes[1]) # affiche 12 notes.append(14) # ajoute 14 \u00e0 la liste Exercice Cr\u00e9er une liste contenant trois pr\u00e9noms et afficher le deuxi\u00e8me.","title":"2. S\u00e9quences (cha\u00eenes, listes)"},{"location":"Secondes/bases_python/#3-instructions-conditionnelles","text":"Elles permettent d\u2019 ex\u00e9cuter du code seulement si une condition est vraie . age = 17 if age >= 18: print(\"Majeur\") else: print(\"Mineur\") On peut ajouter plusieurs cas avec elif . note = 15 if note >= 16: print(\"Tr\u00e8s bien\") elif note >= 12: print(\"Assez bien\") else: print(\"\u00c0 am\u00e9liorer\") Exercice Demander \u00e0 l\u2019utilisateur son \u00e2ge avec input() , puis afficher : - \u00ab Mineur \u00bb si l\u2019\u00e2ge est < 18 - \u00ab Majeur \u00bb sinon","title":"3. Instructions conditionnelles"},{"location":"Secondes/bases_python/#4-boucles","text":"Les boucles permettent de r\u00e9p\u00e9ter des instructions . Boucle born\u00e9e : on conna\u00eet \u00e0 l\u2019avance le nombre de r\u00e9p\u00e9titions. for i in range(5): print(\"Bonjour\", i) Boucle non born\u00e9e : on r\u00e9p\u00e8te tant qu\u2019une condition est vraie. n = 0 while n < 5: print(\"n =\", n) n = n + 1 Exercice \u00c9crire un programme qui affiche les entiers de 1 \u00e0 10 avec une boucle while .","title":"4. Boucles"},{"location":"Secondes/bases_python/#5-fonctions","text":"Une fonction permet de regrouper un ensemble d\u2019instructions sous un nom. On peut ensuite l\u2019 appeler autant de fois que n\u00e9cessaire. def carre(x): return x * x print(carre(5)) # affiche 25 \ud83d\udc49 def sert \u00e0 d\u00e9finir la fonction. return renvoie le r\u00e9sultat. Exercice \u00c9crire une fonction aire_rectangle(longueur, largeur) qui renvoie l\u2019aire du rectangle. Tester avec plusieurs valeurs.","title":"5. Fonctions"},{"location":"Secondes/bases_python/#conclusion","text":"Avec ces bases (variables, s\u00e9quences, conditions, boucles, fonctions), on peut d\u00e9j\u00e0 : - r\u00e9soudre des probl\u00e8mes concrets, - mod\u00e9liser des ph\u00e9nom\u00e8nes, - \u00e9crire des programmes utiles et r\u00e9utilisables. C\u2019est la fondation de l\u2019apprentissage en NSI.","title":"Conclusion"},{"location":"Terminales/Terminales/","text":"NSI - Terminales","title":"Accueil"},{"location":"Terminales/Terminales/#nsi-terminales","text":"","title":"NSI - Terminales"}]}